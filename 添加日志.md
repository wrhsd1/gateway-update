修改了一下 能将调用日志打印并保存修改 src/handlers/responseHandlers.ts中的responseHandler函数，添加以下内容
```***
import { Options, Params } from '../types/requestBody';
import * as fs from 'fs';
import * as path from 'path';

  if (providerConfig?.getConfig) {
    providerTransformers =
      providerConfig.getConfig(gatewayRequest).responseTransforms;
  }

  // Get the current time in Beijing timezone (GMT+8) with custom format YYYY-MM-DD HH:mm:ss
  const beijingTime = new Date().toLocaleString("en-US", { timeZone: "Asia/Shanghai" });

  // Log the request time, provider, request URL, response status, and model value
  console.log(`${response.status}:${beijingTime}|${gatewayRequest.model}|${requestURL}`);

  // Path to the log file
  const logFilePath = path.join(process.cwd(), 'public', 'log.log');

  // Ensure the 'public' directory exists
  if (!fs.existsSync(path.join(process.cwd(), 'public'))) {
    fs.mkdirSync(path.join(process.cwd(), 'public'));
  }

  // Log content to be written
  const logContent = `${response.status}:${beijingTime}|${gatewayRequest.model}|${requestURL}\n`;

  // Read existing logs if the log file exists
  let existingLogs = '';
  if (fs.existsSync(logFilePath)) {
    existingLogs = fs.readFileSync(logFilePath, 'utf-8');
  }

  // Combine the new log with existing logs
  const allLogs = logContent + existingLogs;

  // Split the logs into an array of lines
  const logLines = allLogs.trim().split('\n');

  // Keep only the first 1000 lines
  const trimmedLogs = logLines.slice(0, 1000).join('\n');

  // Write the trimmed logs back to the file
  fs.writeFileSync(logFilePath, trimmedLogs);

  // Checking status 200 so that errors are not considered as stream mode.
```
增加前1000条显示的限制：
```  if (providerConfig?.getConfig) {
    providerTransformers =
      providerConfig.getConfig(gatewayRequest).responseTransforms;
  }

    // Get the current time in Beijing timezone (GMT+8) with custom format YYYY-MM-DD HH:mm:ss
  const beijingTime = new Date().toLocaleString("en-US", { timeZone: "Asia/Shanghai" }); 

  // Log the request time, provider, request URL, response status, and model value
  console.log(`${response.status}:${beijingTime}|${gatewayRequest.model}|${requestURL}`);
  // Path to the log file
  const logFilePath = path.join(process.cwd(), 'public', 'log.log');
  // Ensure the 'public' directory exists
  if (!fs.existsSync(path.join(process.cwd(), 'public'))) {
    fs.mkdirSync(path.join(process.cwd(), 'public'));
  }
  // Log content to be written
  const logContent = `${response.status}:${beijingTime}|${gatewayRequest.model}|${requestURL}\n`;
  
  // Read existing logs and limit to latest 1000 entries
  if (fs.existsSync(logFilePath)) {
    const existingLogs = fs.readFileSync(logFilePath, 'utf-8');
    const logLines = existingLogs.split('\n').filter(line => line.trim());
    const limitedLogs = [logContent.trim(), ...logLines.slice(0, 999)].join('\n') + '\n';
    fs.writeFileSync(logFilePath, limitedLogs);
  } else {
    fs.writeFileSync(logFilePath, logContent);
  }  
  
  // Checking status 200 so that errors are not considered as stream mode.
```